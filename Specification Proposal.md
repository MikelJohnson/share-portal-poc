Freedesktop Share Specification Proposal
=============

## Overview
This specification is inspired by Android's share system. A brief overview can be found [here](https://blog.esper.io/android-14-share-menu/#how-the-android-sharesheet-works). (Tldr: app pass info using intents, which contain stuff like mime type and stuff shared)

Unlike Android where intents are tightly knit into the system (in fact it's the way the apps are launched!), we have to make to do with desktop files and dbus.

Now the second inspiration for this specification are [application actions](https://specifications.freedesktop.org/desktop-entry-spec/1.1/ar01s09.html). In fact the .desktop part shares a lot of similarities with that spec.

One questionable part of this spec is the use of uuids. This will be covered later in this file.

## Definitions
- Share target - basic action provided by app that include Name, Icon and exec path that will be called when this action is executed. They are also referred to as static in this document.
- Dynamic target - this is a target provided by app during runtime for targets that aren't static. This includes people, notes, etc. (Think of it as a version of Android's direct share)
- Extras - concept directly inspired by Android intent system. This includes all the extra data include with share data and allows for extensibility
- Share uuid - uuid that is shared with app. The app can use this uuid to retrieved shared data.
- Target uuid - uuid of a dynamic target. This is generated by the app and provided as a part of dynamic target. If a dynamic target is chosen during share process, the uuid will be passed to the app for identification purposes.

## Desktop file
 ``` .desktop
[Desktop Entry]
Share=Generic;ChangeProfileImage;Debug;
DynamicShareExec=foo --dynamic --share-mime=%m --share-uuid=%s --target-uuid=%t
```

The [Desktop Entry] has two new keys:
- Share - this is a list of all share targets delimited by semicolon
- DynamicShareExec - program to execute for this share target. Requires the following field codes:
    - %m - mime type of shared content
    - %s - share uuid
    - %t - target uuid

```
[Desktop Share Generic]
Name=Share with peeps
Icon=group
Exec=foo --send --share-mime=%m --share-uuid=%s
MimeType=image/png;text/plain;
AcceptsMultipleFiles=true
```

This specification introduces a new share entry group type. The share group is a group named Desktop Share %s, where %s is the share target identifier. 

Each group can have the following keys:
- Name - the name of the share target, this only needs to be unambiguous within one application and should not include the application name. (localestring)
-  Icon to be shown together with the share target. If the name is an absolute path, the given file will be used. If the name is not an absolute path, the algorithm described in the Icon Theme Specification will be used to locate the icon. Implementations may choose to ignore it. (iconstring)
- Program to execute for this action, possibly with the following arguments required: (string)
    - %m - mime type of shared content
    - %s - share uuid
- MimeType - mime types accepted by share target delimited by semicolon. The list may be different from [Desktop Entry], be it a subset or something completely different. If target can't handle a MimeType it won't be shown during share process.
- AcceptsMultipleFiles - whether the share target can handle multiple files. If false target won't be shown when sharing multiple files.  Defaults to false (boolean)

## DBus interface (org.freedesktop.Share)
``` xml
<!DOCTYPE node PUBLIC "-//freedesktop//DTD D-BUS Object Introspection 1.0//EN"
    "http://www.freedesktop.org/standards/dbus/1.0/introspect.dtd">
<node>
    <interface name="org.freedesktop.Share">
        <method name="Send">
            <arg name="mime" type="s" direction="in"/>
            <arg name="extras" type="a{sv}" direction="in"/>
            <annotation name="org.qtproject.QtDBus.QtTypeName.In1" value="QVariantMap"/>
        </method>
        <method name="Receive">
            <arg name="uuid" type="s" direction="in"/>
            <arg name="extras" type="a{sv}" direction="out"/>
            <annotation name="org.qtproject.QtDBus.QtTypeName.Out0" value="QVariantMap"/>
        </method>
        <method name="DynamicRegister">
            <arg name="app" type="s" direction="in"/>
            <arg name="targets" type="aa{sv}" direction="in"/>
            <annotation name="org.qtproject.QtDBus.QtTypeName.In1" value="QList&lt;QVariantMap&gt;"/>
        </method>
        <method name="DynamicClear">
            <arg name="app" type="s" direction="in"/>
        </method>
    </interface>
</node>
```
## Extras
Can be vendored ("x-vendor-name.").
The value type for the extras dictionary in D-BUS is of the DBUS_TYPE_VARIANT container type. This allows different data types (string, integer, boolean, etc.) to be used for hints. When adding a dictionary of hints, this type must be used, rather than putting the actual extra value in as the dictionary value. 

The only necessary value is "text" when sharing text and "files" when sharing files.

<table>
<thead>
  <tr>
    <th>Name</th>
    <th>Value Type</th>
    <th>Description</th>
  </tr>
</thead>
<tbody>
  <tr>
    <td>title</td>
    <td>STRING</td>
    <td>Title of shared data.</td>
  </tr>
  <tr>
    <td>description</td>
    <td>STRING</td>
    <td>Description of shared data. Useful when sharing stuff with description (App store entries, video description etc.)</td>
  </tr>
  <tr>
    <td>text</td>
    <td>STRING</td>
    <td>Shared text. Only used when mime is text</td>
  </tr>
  <tr>
    <td>files</td>
    <td>as</td>
    <td>uris of shared files. Unused when mime is text</td>
  </tr>
</tbody>
</table>

## Target
The data that describes dynamics target. All field are required.
<table>
<thead>
  <tr>
    <th>Name</th>
    <th>Value Type</th>
    <th>Description</th>
  </tr>
</thead>
<tbody>
  <tr>
    <td>uuid</td>
    <td>STRING</td>
    <td>Target uuid</td>
  </tr>
  <tr>
    <td>title</td>
    <td>STRING</td>
    <td>Title of target e.g. name of a person or name of a journal. </td>
  </tr>
  <tr>
    <td>image</td>
    <td>STRING</td>
    <td>URI of image used (e.g. image of a contact)</td>
  </tr>
  <tr>
    <td>mime</td>
    <td>as</td>
    <td>Mime types that the target accepts. If target can't handle a MimeType it won't be shown during share process.</td>
  </tr>
  <tr>
    <td>acceptsMultipleFiles</td>
    <td>BOOLEAN</td>
    <td>Whether the share target can handle multiple files. If false target won't be shown when sharing multiple files.  Defaults to false (boolean)</td>
  </tr>
  <tr>
    <td>priority</td>
    <td>INT32</td>
    <td>Priority of the target. Can be used when determining order of dynamic target (For example people that you chat with most often)</td>
  </tr>
</tbody>
</table>

## org.freedesktop.Share.Send
void org.freedesktop.Share.Send (mime, extras);
STRING mime;
a{sv} extras;

Sends share data to the share server. 

<table>
<thead>
  <tr>
    <th>Name</th>
    <th>Value Type</th>
    <th>Description</th>
  </tr>
</thead>
<tbody>
  <tr>
    <td>mime</td>
    <td>STRING</td>
    <td>Mime type of shared data. Can be text ("text/plain")</td>
  </tr>
  <tr>
    <td>extras</td>
    <td>a{sv}</td>
    <td>Extra data that can be passed to the server from the client program. Can be used to pass along information, that the server may be able to make use of. See Extras.</td>
  </tr>
</tbody>
</table>

## org.freedesktop.Share.Receive
extras org.freedesktop.Share.Receive (uuid);
STRING uuid;
a{sv} extras;

Sends share data to the share server. 

<table>
<thead>
  <tr>
    <th>Name</th>
    <th>Value Type</th>
    <th>Description</th>
  </tr>
</thead>
<tbody>
  <tr>
    <td>uuid</td>
    <td>STRING</td>
    <td>Share uuid that was passed to the app using the desktop file. See Desktop Share group</td>
  </tr>
  <tr>
    <td>extras</td>
    <td>a{sv}</td>
    <td>Extra data that was passed to the server by send method. See Extras.</td>
  </tr>
</tbody>
</table>

## org.freedesktop.Share.DynamicRegister
void org.freedesktop.Share.DynamicRegister (app, targets);
STRING app;
aa{sv} targets;

Sends dynamic targets data to the share server. Will overwrite existing dynamic targets data.

<table>
<thead>
  <tr>
    <th>Name</th>
    <th>Value Type</th>
    <th>Description</th>
  </tr>
</thead>
<tbody>
  <tr>
    <td>app</td>
    <td>STRING</td>
    <td>uri of desktop file that used the method</td>
  </tr>
  <tr>
    <td>targets</td>
    <td>aa{sv}</td>
    <td>Array of dynamic targets (target[]) that can be seen during sharing process. See Target. </td>
  </tr>
</tbody>
</table>

## org.freedesktop.Share.DynamicClear
void org.freedesktop.Share.DynamicClear (app);
STRING app;

Clears dynamic targets data from the share server.

<table>
<thead>
  <tr>
    <th>Name</th>
    <th>Value Type</th>
    <th>Description</th>
  </tr>
</thead>
<tbody>
  <tr>
    <td>app</td>
    <td>STRING</td>
    <td>uri of desktop file that used the method</td>
  </tr>
</tbody>
</table>

## Sharing flow
The sharing flow consists of three parts: sending the data, choosing target using the share dialog and receiving the data

### Sending the data
The sending flow is pretty simple: the app calls org.freedesktop.Share.Send with data it wants to send.

After the sharing server receives the data we move on to the next stage. No further action from the sending app is required.

### Choosing target
Next the server show user the share dialog with all the targets (static and dynamic) that have matching mime types (and also accept multiple files if multiple files were sent).

User chooses the target and server launches the appropriate program, exec from group for static targets and DynamicShareExec for dynamic.

### Receiving the data
The app is launched with the mime type of shared content, share uuid and target uuid in case of dynamic target.

The app then calls org.freedesktop.Share.Receive with the share uuid passed, receives the data and presents it to user

## On using uuids
The use of uuids came from the need to pass data while the application isn't running. We could DBusActivatable but I think it would make the implementation more complicated the necessary. By using uuids we can use a simple pull model where everything is handled by the server. Obviously as this is a proposal so this can change later (as anything in this document!).

Given that the opportunity to get data may only last for a few seconds it realistically won't be able to be bruteforced. However if the need arises we could change uuid to a cryptograpgic key or something similar.
